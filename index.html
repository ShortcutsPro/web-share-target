<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      Web Share Target API
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class=
    "remove"></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "CG-DRAFT",
        edDraftURI: "https://wicg.github.io/web-share-target/",
        github: {
          repoURL: "https://github.com/WICG/web-share-target/",
          branch: "master"
        },
        shortName: "web-share-target",
        processVersion: 2017,
        wg: "Web Incubator Community Group",
        wgURI: "https://wicg.io",
        editors: [{
          name: "Matt Giuca",
          company: "Google Inc.",
          companyURL: "https://google.com"
        }],
        otherLinks: [{
          key: "Implementation status",
          data: [{
            value: "Chromium",
            href: "https://www.chromestatus.com/features/5662315307335680"
          }]
        }],
        localBiblio: {
          "WebShare": {
            id: "WebShare",
            title: "Web Share API",
            href: "https://wicg.github.io/web-share",
            authors: [
              "Matt Giuca",
            ],
            status: "Draft Report",
            publisher: "WICG"
          }
        }
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        This specification defines an API that allows websites to receive
        shared content from either the <a data-cite="!WebShare">Web Share
        API</a>, or system events (e.g., shares from native apps).
      </p>
      <p>
        This is a similar mechanism to <a data-cite=
        "HTML#dom-navigator-registerprotocolhandler"><code>navigator.registerProtocolHandler</code></a>,
        in that it works by registering the website with the user agent, to
        later be invoked from another site or native application via the user
        agent (possibly at the discretion of the user). The difference is that
        <a data-cite=
        "HTML#dom-navigator-registerprotocolhandler"><code>registerProtocolHandler</code></a>
        registers the handler via a programmatic API, whereas a Web Share
        Target is is declared in the <a data-cite="!appmanifest">Web App
        Manifest</a>, to be registered at a time of the user agent or user's
        choosing.
      </p>
    </section>
    <section id="sotd">
      <p>
        This is an early draft of the Web Share Target spec.
      </p>
    </section>
    <section>
      <h2>
        Prerequisites
      </h2>
      <p>
        In order to implement this API, it is REQUIRED that the user agent
        implements <a data-cite="!appmanifest">Web App Manifest</a>. This spec
        also re-uses some definitions from the <a data-cite="!WebShare">Web
        Share API</a> spec. Implementation of that spec is NOT REQUIRED to
        implement this one (but it is RECOMMENDED).
      </p>
    </section>
    <section class="informative">
      <h2>
        Usage Example
      </h2>
      <p>
        To register a site as a share target, a <a for=
        "WebAppManifest">share_target</a> entry is added to the <a data-cite=
        "appmanifest">Web App Manifest</a>, as shown:
      </p>
      <pre class="example json" title="manifest.webmanifest">
{
  "name": "Includinator",
  "share_target": {
    "url_template": "share.html?title={title}&amp;text={text}&amp;url={url}"
  }
}
</pre>
      <p>
        The <a for="ShareTarget">url_template</a> contains a number of
        placeholder fields that will be replaced with the shared data when the
        target is invoked. Once the fields are replaced, it should be a URL
        that is relative to the directory containing the manifest URL.
      </p>
      <p>
        For the purpose of this example, we assume the manifest is located at
        <code>https://example.org/includinator/manifest.webmanifest</code>.
      </p>
      <pre class="example html" title="share.html">
&lt;html&gt;
  &lt;head&gt;
    &lt;link rel="manifest" href="manifest.webmanifest"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
      window.addEventListener('load', () =&gt; {
        var parsedUrl = new URL(window.location.toString());
        console.log('Title shared: ' + parsedUrl.searchParams.get('title'));
        console.log('Text shared: ' + parsedUrl.searchParams.get('text'));
        console.log('URL shared: ' + parsedUrl.searchParams.get('url'));
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
      <p>
        When a share takes place, if the user selects this app as the share
        target, the user agent populates the fields of the URL template, then
        opens a new browsing context at that URL. Any missing fields are left
        empty (but note that the query parameters are not removed). For
        example, if an incoming share contains the title "My News" and the URL
        <code>http://example.com/news</code>, the user agent will open a new
        window or tab and navigate to:
      </p>
      <pre>
https://example.org/includinator/share.html?title=My%20News&amp;text=&amp;url=http%3A//example.com/news
</pre>
      <p>
        How the handler deals with the shared data is at the handler's
        discretion, and will generally depend on the type of app. Here are some
        suggestions:
      </p>
      <ul>
        <li>An email client might draft a new email, using <code>title</code>
        as the subject of an email, with <code>text</code> and <code>url</code>
        concatenated together as the body.
        </li>
        <li>A social networking app might draft a new post, ignoring
        <code>title</code>, using <code>text</code> as the body of the message
        and adding <code>url</code> as a link. If <code>text</code> is missing,
        it might use <code>url</code> in the body as well. If <code>url</code>
        is missing, it might scan <code>text</code> looking for a URL and add
        that as a link.
        </li>
        <li>A text messaging app might draft a new message, ignoring
        <code>title</code> and using <code>text</code> and <code>url</code>
        concatenated together. It might truncate the text or replace
        <code>url</code> with a short link to fit into the message size.
        </li>
      </ul>
    </section>
    <section>
      <h2>
        Extension to the Web App Manifest
      </h2>
      <p>
        The following IDL extends the <a data-cite="!appmanifest">Web App
        Manifest</a> JSON object.
      </p>
      <div class="issue" title="Manifest spec rework">
        <p>
          This section is written against a proposed future version of the
          Manifest spec currently shown in the preview at <a href=
          "https://github.com/w3c/manifest/issues/613">manifest#613</a>.
        </p>
        <p>
          In this re-work of the spec, a <dfn>WebAppManifest</dfn> dictionary
          defines the manifest in IDL, which we extend here.
        </p>
        <p>
          The current version of the spec defines the manifest as a set of
          algorithms, not an IDL dictionary. If we were writing against the
          current Manifest spec, we would need to hook into the <a data-cite=
          "!appmanifest#dfn-extension-point">extension point</a> in the
          <a data-cite="!appmanifest#dfn-steps-for-processing-a-manifest">steps
          for processing a manifest</a>.
        </p>
      </div>
      <pre class="idl">
dictionary ShareTarget {
  required DOMString url_template;
};

partial dictionary WebAppManifest {
  ShareTarget share_target;
};
</pre>
      <section>
        <h3>
          <code>share_target</code> member
        </h3>
        <p>
          The <dfn for="WebAppManifest">share_target</dfn> member of the
          manifest is a <a>ShareTarget</a> dictionary that declares this
          application to be a <a>web share target</a>, and describes how the
          application receives share data.
        </p>
        <p>
          A <dfn data-lt="web share targets">web share target</dfn> is a web
          site in a <a data-cite="SECURE-CONTEXTS#secure-context">secure
          context</a> with a valid manifest containing a <a for=
          "WebAppManifest">share_target</a> member. A web share target is a
          type of <a data-cite="!WebShare#dfn-share-target">share target</a>.
        </p>
      </section>
      <section data-dfn-for="ShareTarget">
        <h3>
          <code>ShareTarget</code> and its members
        </h3>
        <p>
          The <dfn>ShareTarget</dfn> dictionary contains the following members.
        </p>
        <p>
          The <dfn>url_template</dfn> member describes which share data fields
          are passed to the web share target, and in what format. It contains
          zero or more placeholders of the form
          "<code>{<em>field</em>}</code>". Each <em>field</em> MUST be a valid
          <a data-cite="!WebIDL#prod-identifier">WebIDL identifier</a>, and
          SHOULD be a key of the <a data-cite=
          "!WebShare#dom-sharedata"><code>ShareData</code></a> dictionary.
          After these placeholders are removed, it MUST form a <a data-cite=
          "!URL#valid-url-string">valid URL string</a>.
        </p>
        <div class="note">
          The <code>{</code> and <code>}</code> characters are illegal in a
          <a data-cite="URL#valid-url-string">valid URL string</a>, so they
          always represent a placeholder in the <a for=
          "ShareTarget">url_template</a> string, and do not need to be escaped.
        </div>
        <p>
          Any fields that are not present in the <a for=
          "ShareTarget">url_template</a> will be silently dropped from the
          share payload when sharing to this app. The <a for=
          "ShareTarget">url_template</a> MAY contain fields that are not
          <a data-cite="!WebShare#dom-sharedata"><code>ShareData</code></a>
          keys, for forwards compatibility.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Registration of web share targets
      </h2>
      <p>
        How and when <a>web share targets</a> are "registered" is at the
        discretion of the user agent and/or the end user. In fact,
        "registration" is a user-agent-specific concept that is not formally
        defined here; user agents are NOT REQUIRED to "register" web share
        targets at all; they are only REQUIRED to provide some mechanism to
        convey shared data to a web share target of the end user's choosing.
        User agents MAY consider a web share target "registered" even if it is
        not <a data-cite="!appmanifest#dfn-install">installed</a>.
      </p>
      <p>
        The user agent MAY automatically register all <a>web share targets</a>
        as the user visits the site, but it is RECOMMENDED that more discretion
        is applied, to avoid overwhelming the user with the choice of a large
        number of targets.
      </p>
      <div class="note">
        <p>
          Examples of registration strategies that user agents can employ are:
        </p>
        <ul>
          <li>Only register a web share target once it is <a data-cite=
          "appmanifest#dfn-install">installed</a>.
          </li>
          <li>Only register a web share target once the end user has used the
          site for some period of time.
          </li>
          <li>Explicitly prompt the user to register a web share target
          (perhaps using the same UI as <a data-cite=
          "HTML#dom-navigator-registerprotocolhandler"><code>navigator.registerProtocolHandler</code></a>).
          </li>
        </ul>
      </div>
      <p>
        When presenting the end user with a list of <a>web share targets</a>,
        the user agent MAY use an online service which has pre-indexed
        manifests, and therefore show the user targets that they have never
        visited or explicitly registered.
      </p>
      <p class="issue" title="Explicitly registering share targets">
        We may wish to provide a method for websites to explicitly request to
        prompt the user for handler registration. This would be limited to
        prompting to register the <a for="WebAppManifest">share_target</a>
        already declared in the manifest (not dynamically creating share
        targets). For now, we have omitted such a method from the design to
        keep control in the hands of user agents. It is easier to add such a
        method later than remove it.
      </p>
    </section>
    <section>
      <h2>
        Handling incoming shares
      </h2>
      <p>
        Share events can be sent from a variety of places:
      </p>
      <ul>
        <li>Built-in trigger (e.g., user picks "Share" from a browser's menu,
        to share the URL in the address bar).
        </li>
        <li>A native application.
        </li>
        <li>A web application using the <a data-cite="!WebShare">Web Share
        API</a>.
        </li>
      </ul>
      <p>
        There will usually be a picker that lets the user select a target app.
        This could be the native system app picker, or a user-agent-supplied
        picker. The apps could include other system apps and actions alongside
        the web app handlers.
      </p>
      <p>
        If an event comes from a web app, the <code>data</code> field of the
        event should be a clone of the <code>data</code> parameter to
        <code>navigator.share</code>. If the event comes from some other
        source, the user agent may construct the <code>data</code> object as
        appropriate.
      </p>
    </section>
    <section class="informative">
      <h2>
        Security and privacy considerations
      </h2>
      <div class="issue" title="Normative security issues">
        <ul>
          <li>Can the share target URL be outside of the manifest scope? Is
          this enforced statically (before template substitution) or
          dynamically (after)?
          </li>
          <li>Need to precisely define the secure context requirement. Note
          that the <a data-cite="SECURE-CONTEXTS#secure-context">secure
          context</a> algorithm is defined over an environment settings object,
          not a URL. We need to block share targets that are specified from a
          non-secure manifest OR those final URL is non-secure.
          </li>
        </ul>
      </div>
      <ul>
        <li>Spoofing concerns.
        </li>
        <li>Ensuring that the user is aware of which target they are sharing
        to, as private data may be sent to a third-party site.
        </li>
        <li>HTTPS-only requirement.
        </li>
      </ul>
      <p>
        TODO: Additional security and privacy considerations. Also tidy up the
        above language.
      </p>
    </section>
    <section class="appendix informative">
      <h2>
        Acknowledgments
      </h2>
      <p>
        Thanks to the <a data-cite="web-intents">Web Intents</a> team, who laid
        the groundwork for the web app interoperability use cases. In
        particular, <a href="https://paul.kinlan.me/">Paul Kinlan</a>, who did
        a lot of early advocacy for Web Share and Web Share Target.
      </p>
      <p>
        Thanks to Connie Pyromallis, who wrote an early draft of this spec, and
        helped design and prototype the API.
      </p>
    </section>
  </body>
</html>
